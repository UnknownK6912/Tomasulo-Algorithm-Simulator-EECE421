# Tomasulo-Algorithm-Simulator-EECE421

The project was designed according to a set of requirements outlined in a PDF

# EECE 421 - Project Report

## System Design:

Our system featured a modular design where the different functions of Tomasulo's algorithm are split into different files and combined in the main loop where they are called accordingly. We followed an object-oriented architecture, where the functional units, register file, and reservation stations are defined in discrete classes. These classes, along with the common data bus, are instantiated in the main file. The main loop is where the execution occurs, with every loop iteration simulating a clock cycle.

### Instruction Generator:

Automated instruction generator "InstructionGen.py".

The user can configure the number of instructions generated by the program, the number of registers available, as well as available instructions and their associated probabilities.

The generated instructions are outputted to an "InstructionLog.txt" file, that is then read by the main program.

More details can be found in the "Test Strategy" section of this document.

### Instruction Queue:

Instruction Queue is implemented in the main program. The program reads the full "InstructionLog.txt" and maintains an "instruction_pointer" pointer that points to the next instruction to be issued.

Instructions are only issued in order.

Ideally it will issue a number of instructions = "issue_width", but if all reservation stations are full (structural hazard), it will only issue what it can and stall the instruction(s) that could not be issued, and then attempt to re-issue the stalled instruction(s) in the next clock cycle.

### Register File:

The register file is defined in a class, with class variable array "registers" that stores register values, and array "subscriptions" that stores the subscription of every register in the register file. The class has method "getValue" that either returns the value of the register if the register is not subscribed to a reservation station, or the name of the reservation station that the register is subscribed to. This is done for the case that a reservation station needs to fetch an operand that is still not available in the register file, in which case said reservation station inherits the subscription from the register file to fetch the result as soon as it becomes available on the CDB. The other method is "refresh", which is called at the end of every clock cycle to fetch values from the CDB if they are available. This is the only setter method in this class, as in Tomasulo's algorithm the register file is a subscriber of the CDB, and nothing else can set register values.

### Functional Units:

The functional units are the ALU, MUL/DIV unit, and Load/Store unit. Although each unit differs in its function, the overall methods of the classes implementing each unit are largely the same. Each unit has class variables "clockCycles", "ccExec", "result", "busy", and "tag". Variable "clockCycles" defines the number of clock cycles the unit requires to finish executing. This is used along with "ccExec", which keeps track of the number of clock cycles that have elapsed since the unit has started executing, to return the result of the unit which is stored in "result" only when enough clock cycles have elapsed. Variable "busy" is set when the unit is in the middle of executing and cleared when the unit has finished executing. Variable "tag" simply passes the tag of the reservation station from which the instruction being executed was stored to the CDB. Method "exec" simply executes the instruction and stores the result in "result", as well as updating the other class variables. Method "getResult" is only called when the busy flag is cleared, and returns the value of the result along with the reservation station tag. Method "increment", in the case that the unit is still executing, increments the "ccExec" variable to account for a new clock cycle and checks if "ccExec" has reached the number of clock cycles required to end execution. If the unit has finished execution, it simply returns "False" for convenience in the main loop. Finally, "isBusy" returns the state of the unit, and is used in the implementation of the reservation station.

### Reservation Stations:

The reservation stations for all functional units are implemented in the "STATIONS" class. The class has variables for each functional unit that store both operands and whether they empty and whether the instruction they store is ready to execute. Some units, like the Load/Store unit and MUL/DIV unit, require a variable that specifies the type of operation being done. The method "issueXX", XX being the corresponding functional unit name, gets the instruction and obtains the operands (or reservation station tag in case the operand is not available in the register file) and subscribes destination register to the corresponding reservation station. Method "refreshUnits" is responsible for issuing instructions in the reservation stations to an available corresponding functional unit when they are ready to be executed. It is also responsible for fetching pending operands from the data bus when they become available.

### Common Data Bus:

The common data bus is a simple dictionary defined in the main file. The key values are the names of the functional units, and the value is the result of the corresponding functional unit.

## Test Strategy:

First, we generated the instructions using our "InstructionGen.py" program, where instructions are generated according to the requirements set in the PDF file (supported instructions + formats, number of registers).

The probabilities of each instruction are given as a list.
The user can configure the number of instructions generated by the program, the number of registers available, as well as available instructions and their associated probabilities.

The generated instructions are outputted to an "InstructionLog.txt" file, that is then read by the main program.

In the main program, the user can choose the number of simulated clock cycles, and the processor issue width.

Click run and the full output will be shown in the terminal. It will contain information about every clock cycle, as well as final output metrics.


## Experiments:

We tested the program in 2 scenarios:

1. Clock Cycles = 100 for 1-way issue, 2-way issue, and 4-way issue.
2. Clock Cycles = 1000 for 1-way issue, 2-way issue, and 4-way issue.

## Analysis:

In all our test cases, most of the cycles are stalls

We can see that having a wider instruction issue here does not help, the number of instructions executed will be the same.

Here we are limited by the number of functional units, the lack of pipelining in those units, as well as the absence of any kind of optimizations (such as speculative execution, forwarding).

Hence, in this case, the extra issue width on a processor would be wasted.
