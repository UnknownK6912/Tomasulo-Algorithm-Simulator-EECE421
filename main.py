import ALU
import LS
import MULDIV
import REGISTER
import STATION

# you can generate instructions using the InstructionGen.py file

maxCC = 100
issue_width = 2 # configurable issue width
instruction_file = "InstructionLog.txt" # output file from InstructionGen.py


# functional units instantiation
ALU1 = ALU.ALU()
ALU2 = ALU.ALU()
LS1 = LS.LS()
MULDIV1 = MULDIV.MULDIV()
registers = REGISTER.registerFile()
resStations = STATION.restation()

# CDB structure: Keys are Reservation Station names that produce results
# These RS (reservation station) names are used as tags when executing on FUs
cdb_structure = {"ALU1": None, "ALU2": None, "ALU3": None, 
                 "LOAD1": None, "LOAD2": None, 
                 "MULDIV1": None, "MULDIV2": None}

# reading instructions from "InstructionLog.txt" generated by InstructionGen.py
instructions = []
try:
    with open(instruction_file, "r") as f:
        instructions = [line.strip() for line in f if line.strip()]
except FileNotFoundError:
    print("Error: Instruction file " + str(instruction_file)+ " not found.")
    print("Please generate it using EECE421InstructionGen.py first.")
    exit(1)

if not instructions:
    print("No instructions found in  " + str(instruction_file)+ ".")
    exit(1)

num_total_instructions = len(instructions)
instruction_pointer = 0
retired_instruction_count = 0 # to track completion

print("--- Tomasulo Simulator ---")
print("Issue Width: " + str(issue_width) + "-way")
print("Loaded " + str(num_total_instructions) + " instructions.")
print("Initial Register Values: " + str(registers.registers))
print("--------------------------")

# Metrics
total_cycles = 0
stall_cycles_structural_rs = 0 # Stalls because no RS available
total_rs_occupancy_sum = 0 # Sum of occupied RS slots per cycle
total_ls_buffer_occupancy_sum = 0 # Sum of occupied LS buffer slots per cycle


# Main simulation loop (simulating a processor's clock cycles)
for cc in range(1, maxCC + 1):
    total_cycles = cc
    print(f"\n--- Clock Cycle: {cc} ---")

    # Create a CDB for this cycle's writes
    # Values written to CDB in cycle N are available for pickup in cycle N
    cdb_this_cycle = cdb_structure.copy() # Start with all None

    # Stage 1
    # Increment FUs. 
    # If an operation completes, get its result.
    # The FU's getResult() method returns (value, tag_of_producing_RS)
    
    # ALU1
    was_busy_ALU1 = ALU1.isBusy()
    if ALU1.increment() == False and was_busy_ALU1: # Became free this cycle
        result, tag = ALU1.getResult()
        if result is not None and tag is not None:
            cdb_this_cycle[tag] = result
            print(f"CDB Write: {tag} -> {result}")
            if tag.startswith("ALU") or tag.startswith("MULDIV") or tag.startswith("LOAD"):
                 retired_instruction_count +=1

    # ALU2
    was_busy_ALU2 = ALU2.isBusy()
    if ALU2.increment() == False and was_busy_ALU2:
        result, tag = ALU2.getResult()
        if result is not None and tag is not None:
            cdb_this_cycle[tag] = result
            print(f"CDB Write: {tag} -> {result}")
            if tag.startswith("ALU") or tag.startswith("MULDIV") or tag.startswith("LOAD"):
                 retired_instruction_count +=1

    # MULDIV1
    was_busy_MULDIV1 = MULDIV1.isBusy()
    if MULDIV1.increment() == False and was_busy_MULDIV1:
        result, tag = MULDIV1.getResult()
        if result is not None and tag is not None:
            cdb_this_cycle[tag] = result
            print(f"CDB Write: {tag} -> {result}")
            if tag.startswith("ALU") or tag.startswith("MULDIV") or tag.startswith("LOAD"):
                 retired_instruction_count +=1
    
    # LS1
    was_busy_LS1 = LS1.isBusy()
    if LS1.increment() == False and was_busy_LS1:
        result, tag = LS1.getResult() # For LOAD, tag is "LOAD1" or "LOAD2"
                                      # For STORE, result is None, tag might be "STORE1" or "STORE2"
        if tag is not None: # Tag is always returned
            if result is not None: # LOAD completed
                cdb_this_cycle[tag] = result
                print(f"CDB Write: {tag} -> {result}")
            # For both LOAD and STORE completion:
            if tag.startswith("LOAD") or tag.startswith("STORE"): # STOREs also retire
                retired_instruction_count += 1
                if tag.startswith("STORE"): print(f"Store op {tag} completed execution.")


    # Stage 2, the update phase
    # Reservation stations pick up results from CDB and become ready if all operands are available.
    # Ready instructions in RS are dispatched to FUs if FUs are free.
    # Registers pick up results from CDB.
    
    # RS refresh uses current CDB values to make ops ready and tries to dispatch ready ops
    resStations.refreshUnits(cdb_this_cycle, ALU1, ALU2, MULDIV1, LS1)
    registers.refresh(cdb_this_cycle)

    print(f"Registers: {registers.registers} | Subscriptions: {registers.subscription}")

    # Stage 3
    # Try to issue up to issue_width instructions from the instruction log
    issued_this_cycle_count = 0
    if instruction_pointer < num_total_instructions:
        for i in range(issue_width):
            if instruction_pointer >= num_total_instructions:
                break # No more instructions in the log

            instr_line = instructions[instruction_pointer]
            op_type = instr_line.split(" ")[0].upper() # Ensure uppercase for matching
            
            issued_successfully = False
            
            print(f"Attempting to issue: {instr_line}")

            if op_type in ["ADD", "SUB"]:
                if resStations.issueALU(instr_line, registers):
                    issued_successfully = True
            elif op_type in ["MUL", "DIV"]:
                if resStations.issueMULDIV(instr_line, registers):
                    issued_successfully = True
            elif op_type == "LOAD":
                if resStations.issueLOAD(instr_line, registers):
                    issued_successfully = True
            elif op_type == "STORE":
                if resStations.issueSTORE(instr_line, registers): # Store also needs issuing
                    issued_successfully = True
            else:
                print(f"Error: Unknown instruction type '{op_type}' in: {instr_line}")
                # Optionally, skip this instruction or halt
                instruction_pointer += 1 # Skip malformed instruction
                continue

            if issued_successfully:
                print(f"  Issued: {instr_line}")
                instruction_pointer += 1
                issued_this_cycle_count += 1
            else:
                # Structural hazard: No suitable reservation station available
                print(f"  Stall on issue (Structural Hazard - RS full): {instr_line}")
                stall_cycles_structural_rs += 1
                break # Stop trying to issue more instructions in this cycle if one is stalled
    else:
        print("No more instructions to issue from log.")

    # Collect Metrics for this cycle
    occupied_rs_count = 0
    if not resStations.ALU1Empty: occupied_rs_count +=1
    if not resStations.ALU2Empty: occupied_rs_count +=1
    if not resStations.ALU3Empty: occupied_rs_count +=1
    if not resStations.MULDIV1Empty: occupied_rs_count +=1
    if not resStations.MULDIV2Empty: occupied_rs_count +=1
    total_rs_occupancy_sum += occupied_rs_count
    
    occupied_ls_buffer_count = 0
    if not resStations.LOAD1Empty: occupied_ls_buffer_count +=1
    if not resStations.LOAD2Empty: occupied_ls_buffer_count +=1
    if not resStations.STORE1Empty: occupied_ls_buffer_count +=1
    if not resStations.STORE2Empty: occupied_ls_buffer_count +=1
    total_ls_buffer_occupancy_sum += occupied_ls_buffer_count

    print(f"RS Occupied: {occupied_rs_count}/5 | LS Buffers Occupied: {occupied_ls_buffer_count}/4")
    print(f"Issued this cycle: {issued_this_cycle_count} | Total issued: {instruction_pointer}/{num_total_instructions}")
    print(f"Retired this cycle (approx): see CDB | Total retired: {retired_instruction_count}/{num_total_instructions}")

    # Stage 4
    # Check for simulation completion 
    all_instructions_retired = (retired_instruction_count == num_total_instructions)
    all_units_idle = (not ALU1.isBusy() and not ALU2.isBusy() and
                      not MULDIV1.isBusy() and not LS1.isBusy())
    all_rs_empty = (resStations.ALU1Empty and resStations.ALU2Empty and resStations.ALU3Empty and
                    resStations.MULDIV1Empty and resStations.MULDIV2Empty and
                    resStations.LOAD1Empty and resStations.LOAD2Empty and
                    resStations.STORE1Empty and resStations.STORE2Empty)


    if retired_instruction_count == num_total_instructions and all_units_idle :
        print(f"\n--- Simulation Complete at Clock Cycle: {cc} ---")
        # Ensure any final writes from FUs that just became idle are processed if needed,
        # but the logic above should handle it.
        break
    
    if cc == maxCC:
        print(f"\n--- Simulation Halted at MAX_CC: {maxCC} ---")
        print("Not all instructions may have completed.")

# End of Simulation, print final metrics
print("\n--- Final State & Metrics ---")
print(f"Total Clock Cycles: {total_cycles}")
print(f"Total Instructions Executed (Retired): {retired_instruction_count}") # Should be num_total_instructions if completed

if total_cycles > 0:
    ipc = retired_instruction_count / total_cycles
    print(f"Instructions Per Cycle (IPC): {ipc:.3f}")

    avg_rs_occupancy_abs = total_rs_occupancy_sum / total_cycles
    # Total RS slots = 3 (ALU) + 2 (MULDIV) = 5
    avg_rs_occupancy_perc = (avg_rs_occupancy_abs / 5) * 100 if 5 > 0 else 0
    print(f"Average Reservation Station Occupancy: {avg_rs_occupancy_abs:.2f} slots ({avg_rs_occupancy_perc:.2f}%)")

    avg_ls_buffer_occupancy_abs = total_ls_buffer_occupancy_sum / total_cycles
    # Total LS buffer slots = 2 (LOAD) + 2 (STORE) = 4
    avg_ls_buffer_occupancy_perc = (avg_ls_buffer_occupancy_abs / 4) * 100 if 4 > 0 else 0
    print(f"Average Load/Store Buffer Utilization: {avg_ls_buffer_occupancy_abs:.2f} slots ({avg_ls_buffer_occupancy_perc:.2f}%)")
else:
    print("IPC, RS Occupancy, L/S Buffer Utilization: N/A (0 cycles)")
    
print(f"Stall Cycles due to Structural Hazards (RS Full): {stall_cycles_structural_rs}")
if total_cycles > 0 :
    stall_percentage = (stall_cycles_structural_rs / total_cycles) * 100
    print(f"Percentage of Stall Cycles (RS Full vs Total): {stall_percentage:.2f}%")
else:
    print(f"Percentage of Stall Cycles (RS Full vs Total): N/A (0 cycles)")


print(f"Final Register Values: {registers.registers}")
# print(f"Final CDB state (last cycle's writes): {cdb_this_cycle}") # cdb_this_cycle is local to loop
